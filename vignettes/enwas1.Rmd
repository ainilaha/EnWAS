---
title: "Environment-Wide Association Study (EnWAS)"
date: "Updated on : `r date()`"
output: html_document
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## 0. Pepare for EnWAS

Details can check the previous vignette page.

```{r setup,warning=FALSE,message=FALSE}
library(EnWAS)
library(splines)
library(ggplot2)
library(ggpubr)
library(dplyr)
data("nhanes")
data("exposure_vars")
# phesant_res <- phesant(nhanes)
# nhanes <- phesant_res$data

library(DBI)
nhanes_db <- DBI::dbConnect(RSQLite::SQLite(), "C:\\projects\\data_nhanes\\nhanes_new.sqlite")
dbListTables(nhanes_db)


base_df <- dbGetQuery(nhanes_db, "SELECT demo.SEQN,
                                    (BPXDI1+BPXDI2)/2 AS DIASTOLIC,RIAGENDR,RIDAGEYR,RIDRETH1,BMXBMI,
                                    demo.years
                                  FROM
                                    demo
                                  INNER JOIN body_measures ON demo.SEQN=body_measures.SEQN
                                  INNER JOIN blood_pressure ON demo.SEQN=blood_pressure.SEQN
                                  WHERE
                                      RIDAGEYR>20
                                    AND BMXBMI is not NULL
                                    AND BPXDI1 IS NOT NULL and BPXDI1 <> 0
                                    AND BPXDI2 IS NOT NULL and BPXDI2 <> 0")
base_df$RIDRETH1 <- as.factor(base_df$RIDRETH1)
base_df$RIAGENDR <- as.factor(base_df$RIAGENDR)
base_df$years <- as.factor(base_df$years)

```

## 1. Run EnWAS

```{r enwas, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
# lm_str <- 'diastolic ~ RIDAGEYR*RIAGENDR + BMXBMI + RIDRETH1'
# lm_enwas <- enwas(lm_str, exposure_vars, nhanes)
ns_str <-
  'DIASTOLIC ~ ns(RIDAGEYR, knots = seq(30, 80, by = 10), Boundary.knots=c(20,90)) * RIAGENDR + ns(BMXBMI,knots = c(seq(15, 45, by = 5),seq(45,65,by=10)),Boundary.knots=c(10,75)) + RIDRETH1'

```
### 1.1 Data Preprocess with PHESANT-like tool before EnWAS
Before feeding the data into any model, we probably need to do data preprocess (e.g., clean or fill NAs, drop out columns, and transformation). In the data preprocessing phase, it is essential to properly tidy the data that models can process and learn from the data distributions; as said, “garbage in, garbage out.”  In other words, the outputs of the models may be meaningless if we feed the raw data without tidiness and with too much noise or too little information.

However, it requires a lot of effort to preprocess the data when we have large data sets with thousands of phenotype to check.
For NHANES data, we developed a PHESANT-like tool that can preprocess the data, and it can help convert the data into suitable data types. 

***We may need to discuss how we allow users to configure the tables and prototypes, json file seems OK.***

```{r enwas00, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
enwas_all <- function(base_df=base_df, nhanes_db=nhanes_db,
                      epx_file="C:/projects/EnWAS/data/phenotypes.json",inv=FALSE){
  exposures <- jsonlite::fromJSON(epx_file)
  qc_mtrx <- data.frame(matrix(ncol = 9, nrow = 0))
  xwas_df <- data.frame(matrix(ncol = 9, nrow = 0))
  model_list <- list() ## need to replace with :vector(mode = "list", length = num_var)
  for(tb_name in names(exposures)){
    exprs <- exposures[tb_name][[1]]
    expr_data <- load_exprs(exprs,tb_name,nhanes_db)
    data <- merge(base_df,expr_data$data,by="SEQN")
    ns_enwas <- enwas(ns_str, exprs, data,inv_norm = inv)
    xwas_df <- rbind(xwas_df,ns_enwas$enwas_res)
    qc_mtrx <- rbind(qc_mtrx,ns_enwas$qc_mtx)
    model_list <- c(model_list,ns_enwas$model_list)
  }
  return (list(qc_mtx = qc_mtrx,enwas_res = xwas_df,model_list=model_list))
}

xwas <- enwas_all(base_df,nhanes_db)
forest_plot(xwas$enwas_res,30) # filter out CI contains 0
```




### 3. Inverse Normal Transformation

In addition, the EnWAS model can use inverse normal transformation on the wide association variables, which would be helpful to improve the models' performance when the distributions are skewed.

$$
\operatorname{INT}\left(W_{i}\right)=\Phi^{-1}\left\{\frac{\operatorname{rank}\left(W_{i}\right)-c}{n+1-2 c}\right\}, c \in[0,1 / 2]
$$ where c=3/8 is recommended.

```{r enwas2, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
xwas_inv <- enwas_all(base_df,nhanes_db,inv = TRUE)
forest_plot(xwas_inv$enwas_res,30)
forest_plot_mult(
  list(
    ns = xwas$enwas_res,
    ns_inv = xwas_inv$enwas_res
  ),20
)



enwas_res = data.frame(x=xwas$enwas_res$estimate,
                       x_upper = xwas$enwas_res$upper,
                       x_lower = xwas$enwas_res$lower,
                       y=xwas_inv$enwas_res$estimate,
                       y_upper=xwas_inv$enwas_res$upper,
                       y_lower=xwas_inv$enwas_res$lower,
                       term = xwas_inv$enwas_res$term
                       )


enwas_res |> 
ggplot(aes(x,y,label = term, colour=term)) + 
  geom_point(size=1.5)+
  geom_errorbar(aes(ymin = y_lower, ymax = y_upper))+
  geom_errorbarh(aes(xmin = x_lower,xmax = x_upper)) + geom_text() +theme_minimal()+
  theme(legend.position = "none")+xlab("EnWAS") + ylab("EnWAS INT")

```


### 3.1 Likelihood ratio Inverse Normal Transformation to None transformd


```{r enwas_inv2, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
library(knitr)
library(kableExtra)

# terms <- xwas$enwas_res$term
# lrt_mtx <- matrix(0, nrow = length(terms), ncol = 3)
# colnames(lrt_mtx) <- c("term","LRTstat","P_value")
# lrt_mtx[,1] <- terms
# 
# for (term in terms){
#       non_trans_model <- xwas$model_list[term][[1]]
#       inv_model <- xwas_inv$model_list[term][[1]]
#       vong <- nonnest2::vuongtest(non_trans_model,inv_model)
#       lrt_mtx[i,2] <- round(vong$LRTstat,3)
#       lrt_mtx[i,3] <- round(vong$p_LRT$A,4)
# }
# 
# lrt_mtx <- as.data.frame(lrt_mtx)
# 
# lrt_mtx |> dplyr::arrange(P_value) |> 
#   kbl() |> kable_classic_2(full_width = F)

```



### 1.0  Folate - RBC
Folate, serum
'LBDRFO', # RBC folate (ng/mL)
'LBDRFOSI' # RBC folate (nmol/L)
[cook book](https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/FOLATE_J.htm)

```{r enwas44, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
# fs_exprs = c('LBDRFO', # RBC folate (ng/mL)
#              'LBDRFOSI' # RBC folate (nmol/L)
#           )
# 
# FolateRBC_expr <- load_exprs(fs_exprs,"FolateRBC",nhanes_db)
# data <- merge(base_df,FolateRBC_expr$data,by="SEQN")
# # LBDRFOSI behave very strange without inverse nomral transformation
# ns_enwas_FolateRBC_expr <- enwas(ns_str, fs_exprs, data,inv_norm = TRUE)

```





### 4. P-Value or FDR

```{r p_vales, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
plot_p(list(ns = xwas$enwas_res,  ns_inv = xwas_inv$enwas_res))
```

### 5. QA/QC

```{r aic, echo=TRUE,warning=F, message=FALSE,out.width = '90%',dpi = 200}


xwas$enwas_res |> filter(lower*upper > 0) |>
    dplyr::top_n(30,abs(estimate)) |>
   dplyr::arrange(dplyr::desc(estimate)) |> 
  kbl() |> kable_classic_2(full_width = F)

xwas_inv$enwas_res |> filter(lower*upper > 0) |>
    dplyr::top_n(30,abs(estimate)) |>
   dplyr::arrange(dplyr::desc(estimate)) |> 
  kbl() |> kable_classic_2(full_width = F)







```

### 6. AC/QC plots

```{r lrt, echo=TRUE,warning=F, out.width = '90%',dpi = 200}
# lollipop(qc_mtx,y="Deviance")
# lollipop(qc_mtx,y="Ratio") + ylab("Ratio(%)")
# lollipop(qc_mtx,y="LR")
# lollipop(qc_mtx,y="p_LRT",is_desc = TRUE)
# lollipop(qc_mtx,y="BIC",is_desc = TRUE)
# lollipop(qc_mtx,y="AIC",is_desc = TRUE)
```


### 7. Cross Validation for EnWAS

```{r cv, echo=TRUE,warning=F, out.width = '90%',dpi = 200}

cross_val <- function(model_str,data_set,top_exrs,inv=FALSE,label="DIASTOLIC"){
  
  # years <- levels(data_set$years)
  years <- c("2003-2004","2005-2006","2007-2008","2009-2010")
  len_year <- length(years)
  mse_mtx <- matrix(0, nrow = length(top_exrs), ncol = len_year)
  rownames(mse_mtx) <- top_exrs
  colnames(mse_mtx) <- years

  for (i in 1:len_year){
      cv_train <- data_set[data_set$years != years[i], ]
      cv_test <- data_set[data_set$years == years[i], ]
      mse <- enwas_cv(model_str,top_exrs,train_set = cv_train,
                      test_set = cv_test,lab_col = label,
                      inv_norm =inv)
      mse_mtx[,i] <- mse
  }
 mse_df <- as.data.frame(reshape2::melt(mse_mtx))
 colnames(mse_df) <- c("Exposures","Years","MSE")
 mse_df

}





top_n_exprs <- xwas$enwas_res |> filter(lower*upper > 0) |>
    dplyr::top_n(30,abs(estimate)) |>
   dplyr::arrange(dplyr::desc(estimate)) 
top_n_exprs$term



exposures <- jsonlite::fromJSON("C:/projects/EnWAS/data/phenotypes.json")
cv_df <- data.frame(matrix(ncol = 3, nrow = 0))
for(tb_name in names(exposures)){
  exprs <- exposures[tb_name][[1]]
  exprs <- intersect(top_n_exprs$term,exprs)
  if(length(exprs)>0){
    expr_data <- load_exprs(exprs,tb_name,nhanes_db)
    data <- merge(base_df,expr_data$data,by="SEQN")
    # print(head(data))
    cv_tmp <- cross_val(ns_str,data,exprs)
    cv_df <- rbind(cv_df,cv_tmp)
  }
  
}


cv_df |>
  ggplot(aes(x=Exposures,y=MSE,fill=Exposures )) +
  geom_boxplot()+
  scale_x_discrete(guide = guide_axis(angle = 45))+
  scale_y_continuous(limits = quantile(cv_df$MSE, c(0.0, 0.9)))+
  theme_minimal()+theme(legend.position="none")


dbDisconnect(nhanes_db)

```
